// This file was generated by gir (https://github.com/gtk-rs/gir)
// from 
// from gir-files
// DO NOT EDIT

use crate::{Bin,Tab,TabSwitcherTabBarBehavior};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_,fmt,mem::transmute};

glib::wrapper! {
    #[doc(alias = "HeTabSwitcher")]
    pub struct TabSwitcher(Object<ffi::HeTabSwitcher, ffi::HeTabSwitcherClass>) @extends Bin, gtk::Widget, gobject::InitiallyUnowned, @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget;

    match fn {
        type_ => || ffi::he_tab_switcher_get_type(),
    }
}

impl TabSwitcher {
        pub const NONE: Option<&'static TabSwitcher> = None;
    

    #[doc(alias = "he_tab_switcher_new")]
    pub fn new() -> TabSwitcher {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::he_tab_switcher_new())
        }
    }

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`TabSwitcher`] objects.
            ///
            /// This method returns an instance of [`TabSwitcherBuilder`](crate::builders::TabSwitcherBuilder) which can be used to create [`TabSwitcher`] objects.
            pub fn builder() -> TabSwitcherBuilder {
                TabSwitcherBuilder::default()
            }
        
}

impl Default for TabSwitcher {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

#[derive(Clone, Default)]
// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`TabSwitcher`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct TabSwitcherBuilder {
    tab_bar_behavior: Option<TabSwitcherTabBarBehavior>,
    allow_duplicate_tabs: Option<bool>,
    allow_drag: Option<bool>,
    allow_pinning: Option<bool>,
    allow_closing: Option<bool>,
    allow_new_window: Option<bool>,
    current: Option<Tab>,
    menu: Option<gio::Menu>,
    actions: Option<gio::SimpleActionGroup>,
    child: Option<gtk::Widget>,
    can_focus: Option<bool>,
    can_target: Option<bool>,
    css_classes: Option<Vec<String>>,
    css_name: Option<String>,
    //cursor: /*Unknown type*/,
    focus_on_click: Option<bool>,
    focusable: Option<bool>,
    halign: Option<gtk::Align>,
    has_tooltip: Option<bool>,
    height_request: Option<i32>,
    hexpand: Option<bool>,
    hexpand_set: Option<bool>,
    //layout-manager: /*Unknown type*/,
    margin_bottom: Option<i32>,
    margin_end: Option<i32>,
    margin_start: Option<i32>,
    margin_top: Option<i32>,
    name: Option<String>,
    opacity: Option<f64>,
    //overflow: /*Unknown type*/,
    receives_default: Option<bool>,
    sensitive: Option<bool>,
    tooltip_markup: Option<String>,
    tooltip_text: Option<String>,
    valign: Option<gtk::Align>,
    vexpand: Option<bool>,
    vexpand_set: Option<bool>,
    visible: Option<bool>,
    width_request: Option<i32>,
    //accessible-role: /*Unknown type*/,
}

impl TabSwitcherBuilder {
    // rustdoc-stripper-ignore-next
    /// Create a new [`TabSwitcherBuilder`].
    pub fn new() -> Self {
        Self::default()
    }


    // rustdoc-stripper-ignore-next
    /// Build the [`TabSwitcher`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> TabSwitcher {
        let mut properties: Vec<(&str, &dyn ToValue)> = vec![];
if let Some(ref tab_bar_behavior) = self.tab_bar_behavior {
                properties.push(("tab-bar-behavior", tab_bar_behavior));
            }
if let Some(ref allow_duplicate_tabs) = self.allow_duplicate_tabs {
                properties.push(("allow-duplicate-tabs", allow_duplicate_tabs));
            }
if let Some(ref allow_drag) = self.allow_drag {
                properties.push(("allow-drag", allow_drag));
            }
if let Some(ref allow_pinning) = self.allow_pinning {
                properties.push(("allow-pinning", allow_pinning));
            }
if let Some(ref allow_closing) = self.allow_closing {
                properties.push(("allow-closing", allow_closing));
            }
if let Some(ref allow_new_window) = self.allow_new_window {
                properties.push(("allow-new-window", allow_new_window));
            }
if let Some(ref current) = self.current {
                properties.push(("current", current));
            }
if let Some(ref menu) = self.menu {
                properties.push(("menu", menu));
            }
if let Some(ref actions) = self.actions {
                properties.push(("actions", actions));
            }
if let Some(ref child) = self.child {
                properties.push(("child", child));
            }
if let Some(ref can_focus) = self.can_focus {
                properties.push(("can-focus", can_focus));
            }
if let Some(ref can_target) = self.can_target {
                properties.push(("can-target", can_target));
            }
if let Some(ref css_classes) = self.css_classes {
                properties.push(("css-classes", css_classes));
            }
if let Some(ref css_name) = self.css_name {
                properties.push(("css-name", css_name));
            }
if let Some(ref focus_on_click) = self.focus_on_click {
                properties.push(("focus-on-click", focus_on_click));
            }
if let Some(ref focusable) = self.focusable {
                properties.push(("focusable", focusable));
            }
if let Some(ref halign) = self.halign {
                properties.push(("halign", halign));
            }
if let Some(ref has_tooltip) = self.has_tooltip {
                properties.push(("has-tooltip", has_tooltip));
            }
if let Some(ref height_request) = self.height_request {
                properties.push(("height-request", height_request));
            }
if let Some(ref hexpand) = self.hexpand {
                properties.push(("hexpand", hexpand));
            }
if let Some(ref hexpand_set) = self.hexpand_set {
                properties.push(("hexpand-set", hexpand_set));
            }
if let Some(ref margin_bottom) = self.margin_bottom {
                properties.push(("margin-bottom", margin_bottom));
            }
if let Some(ref margin_end) = self.margin_end {
                properties.push(("margin-end", margin_end));
            }
if let Some(ref margin_start) = self.margin_start {
                properties.push(("margin-start", margin_start));
            }
if let Some(ref margin_top) = self.margin_top {
                properties.push(("margin-top", margin_top));
            }
if let Some(ref name) = self.name {
                properties.push(("name", name));
            }
if let Some(ref opacity) = self.opacity {
                properties.push(("opacity", opacity));
            }
if let Some(ref receives_default) = self.receives_default {
                properties.push(("receives-default", receives_default));
            }
if let Some(ref sensitive) = self.sensitive {
                properties.push(("sensitive", sensitive));
            }
if let Some(ref tooltip_markup) = self.tooltip_markup {
                properties.push(("tooltip-markup", tooltip_markup));
            }
if let Some(ref tooltip_text) = self.tooltip_text {
                properties.push(("tooltip-text", tooltip_text));
            }
if let Some(ref valign) = self.valign {
                properties.push(("valign", valign));
            }
if let Some(ref vexpand) = self.vexpand {
                properties.push(("vexpand", vexpand));
            }
if let Some(ref vexpand_set) = self.vexpand_set {
                properties.push(("vexpand-set", vexpand_set));
            }
if let Some(ref visible) = self.visible {
                properties.push(("visible", visible));
            }
if let Some(ref width_request) = self.width_request {
                properties.push(("width-request", width_request));
            }
        glib::Object::new::<TabSwitcher>(&properties)

    }

    pub fn tab_bar_behavior(mut self, tab_bar_behavior: TabSwitcherTabBarBehavior) -> Self {
        self.tab_bar_behavior = Some(tab_bar_behavior);
        self
    }

    pub fn allow_duplicate_tabs(mut self, allow_duplicate_tabs: bool) -> Self {
        self.allow_duplicate_tabs = Some(allow_duplicate_tabs);
        self
    }

    pub fn allow_drag(mut self, allow_drag: bool) -> Self {
        self.allow_drag = Some(allow_drag);
        self
    }

    pub fn allow_pinning(mut self, allow_pinning: bool) -> Self {
        self.allow_pinning = Some(allow_pinning);
        self
    }

    pub fn allow_closing(mut self, allow_closing: bool) -> Self {
        self.allow_closing = Some(allow_closing);
        self
    }

    pub fn allow_new_window(mut self, allow_new_window: bool) -> Self {
        self.allow_new_window = Some(allow_new_window);
        self
    }

    pub fn current(mut self, current: &impl IsA<Tab>) -> Self {
        self.current = Some(current.clone().upcast());
        self
    }

    pub fn menu(mut self, menu: &gio::Menu) -> Self {
        self.menu = Some(menu.clone());
        self
    }

    pub fn actions(mut self, actions: &impl IsA<gio::SimpleActionGroup>) -> Self {
        self.actions = Some(actions.clone().upcast());
        self
    }

    pub fn child(mut self, child: &impl IsA<gtk::Widget>) -> Self {
        self.child = Some(child.clone().upcast());
        self
    }

    pub fn can_focus(mut self, can_focus: bool) -> Self {
        self.can_focus = Some(can_focus);
        self
    }

    pub fn can_target(mut self, can_target: bool) -> Self {
        self.can_target = Some(can_target);
        self
    }

    pub fn css_classes(mut self, css_classes: Vec<String>) -> Self {
        self.css_classes = Some(css_classes);
        self
    }

    pub fn css_name(mut self, css_name: &str) -> Self {
        self.css_name = Some(css_name.to_string());
        self
    }

    pub fn focus_on_click(mut self, focus_on_click: bool) -> Self {
        self.focus_on_click = Some(focus_on_click);
        self
    }

    pub fn focusable(mut self, focusable: bool) -> Self {
        self.focusable = Some(focusable);
        self
    }

    pub fn halign(mut self, halign: gtk::Align) -> Self {
        self.halign = Some(halign);
        self
    }

    pub fn has_tooltip(mut self, has_tooltip: bool) -> Self {
        self.has_tooltip = Some(has_tooltip);
        self
    }

    pub fn height_request(mut self, height_request: i32) -> Self {
        self.height_request = Some(height_request);
        self
    }

    pub fn hexpand(mut self, hexpand: bool) -> Self {
        self.hexpand = Some(hexpand);
        self
    }

    pub fn hexpand_set(mut self, hexpand_set: bool) -> Self {
        self.hexpand_set = Some(hexpand_set);
        self
    }

    pub fn margin_bottom(mut self, margin_bottom: i32) -> Self {
        self.margin_bottom = Some(margin_bottom);
        self
    }

    pub fn margin_end(mut self, margin_end: i32) -> Self {
        self.margin_end = Some(margin_end);
        self
    }

    pub fn margin_start(mut self, margin_start: i32) -> Self {
        self.margin_start = Some(margin_start);
        self
    }

    pub fn margin_top(mut self, margin_top: i32) -> Self {
        self.margin_top = Some(margin_top);
        self
    }

    pub fn name(mut self, name: &str) -> Self {
        self.name = Some(name.to_string());
        self
    }

    pub fn opacity(mut self, opacity: f64) -> Self {
        self.opacity = Some(opacity);
        self
    }

    pub fn receives_default(mut self, receives_default: bool) -> Self {
        self.receives_default = Some(receives_default);
        self
    }

    pub fn sensitive(mut self, sensitive: bool) -> Self {
        self.sensitive = Some(sensitive);
        self
    }

    pub fn tooltip_markup(mut self, tooltip_markup: &str) -> Self {
        self.tooltip_markup = Some(tooltip_markup.to_string());
        self
    }

    pub fn tooltip_text(mut self, tooltip_text: &str) -> Self {
        self.tooltip_text = Some(tooltip_text.to_string());
        self
    }

    pub fn valign(mut self, valign: gtk::Align) -> Self {
        self.valign = Some(valign);
        self
    }

    pub fn vexpand(mut self, vexpand: bool) -> Self {
        self.vexpand = Some(vexpand);
        self
    }

    pub fn vexpand_set(mut self, vexpand_set: bool) -> Self {
        self.vexpand_set = Some(vexpand_set);
        self
    }

    pub fn visible(mut self, visible: bool) -> Self {
        self.visible = Some(visible);
        self
    }

    pub fn width_request(mut self, width_request: i32) -> Self {
        self.width_request = Some(width_request);
        self
    }
}

pub trait TabSwitcherExt: 'static {
    #[doc(alias = "he_tab_switcher_get_n_tabs")]
    #[doc(alias = "get_n_tabs")]
    fn n_tabs(&self) -> i32;

    #[doc(alias = "he_tab_switcher_get_tabs")]
    #[doc(alias = "get_tabs")]
    fn tabs(&self) -> Vec<Tab>;

    #[doc(alias = "he_tab_switcher_get_tab_bar_behavior")]
    #[doc(alias = "get_tab_bar_behavior")]
    fn tab_bar_behavior(&self) -> TabSwitcherTabBarBehavior;

    #[doc(alias = "he_tab_switcher_set_tab_bar_behavior")]
    fn set_tab_bar_behavior(&self, value: TabSwitcherTabBarBehavior);

    #[doc(alias = "he_tab_switcher_get_tab_position")]
    #[doc(alias = "get_tab_position")]
    fn tab_position(&self, tab: &impl IsA<Tab>) -> i32;

    #[doc(alias = "he_tab_switcher_get_allow_duplicate_tabs")]
    #[doc(alias = "get_allow_duplicate_tabs")]
    fn allows_duplicate_tabs(&self) -> bool;

    #[doc(alias = "he_tab_switcher_set_allow_duplicate_tabs")]
    fn set_allow_duplicate_tabs(&self, value: bool);

    #[doc(alias = "he_tab_switcher_get_allow_drag")]
    #[doc(alias = "get_allow_drag")]
    fn allows_drag(&self) -> bool;

    #[doc(alias = "he_tab_switcher_set_allow_drag")]
    fn set_allow_drag(&self, value: bool);

    #[doc(alias = "he_tab_switcher_get_allow_pinning")]
    #[doc(alias = "get_allow_pinning")]
    fn allows_pinning(&self) -> bool;

    #[doc(alias = "he_tab_switcher_set_allow_pinning")]
    fn set_allow_pinning(&self, value: bool);

    #[doc(alias = "he_tab_switcher_get_allow_closing")]
    #[doc(alias = "get_allow_closing")]
    fn allows_closing(&self) -> bool;

    #[doc(alias = "he_tab_switcher_set_allow_closing")]
    fn set_allow_closing(&self, value: bool);

    #[doc(alias = "he_tab_switcher_get_allow_new_window")]
    #[doc(alias = "get_allow_new_window")]
    fn allows_new_window(&self) -> bool;

    #[doc(alias = "he_tab_switcher_set_allow_new_window")]
    fn set_allow_new_window(&self, value: bool);

    #[doc(alias = "he_tab_switcher_get_current")]
    #[doc(alias = "get_current")]
    fn current(&self) -> Tab;

    #[doc(alias = "he_tab_switcher_set_current")]
    fn set_current(&self, value: &impl IsA<Tab>);

    #[doc(alias = "he_tab_switcher_insert_tab")]
    fn insert_tab(&self, tab: &impl IsA<Tab>, index: i32) -> u32;

    #[doc(alias = "he_tab_switcher_remove_tab")]
    fn remove_tab(&self, tab: &impl IsA<Tab>);

    #[doc(alias = "he_tab_switcher_get_menu")]
    #[doc(alias = "get_menu")]
    fn menu(&self) -> gio::Menu;

    #[doc(alias = "he_tab_switcher_get_actions")]
    #[doc(alias = "get_actions")]
    fn actions(&self) -> gio::SimpleActionGroup;

    fn set_menu(&self, menu: Option<&gio::Menu>);

    #[doc(alias = "tab-added")]
    fn connect_tab_added<F: Fn(&Self, &Tab) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "tab-removed")]
    fn connect_tab_removed<F: Fn(&Self, &Tab) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "tab-switched")]
    fn connect_tab_switched<F: Fn(&Self, Option<&Tab>, &Tab) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "tab-moved")]
    fn connect_tab_moved<F: Fn(&Self, &Tab) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "tab-duplicated")]
    fn connect_tab_duplicated<F: Fn(&Self, &Tab) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "new-tab-requested")]
    fn connect_new_tab_requested<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "close-tab-requested")]
    fn connect_close_tab_requested<F: Fn(&Self, &Tab) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "n-tabs")]
    fn connect_n_tabs_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "tabs")]
    fn connect_tabs_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "tab-bar-behavior")]
    fn connect_tab_bar_behavior_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "allow-duplicate-tabs")]
    fn connect_allow_duplicate_tabs_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "allow-drag")]
    fn connect_allow_drag_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "allow-pinning")]
    fn connect_allow_pinning_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "allow-closing")]
    fn connect_allow_closing_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "allow-new-window")]
    fn connect_allow_new_window_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "current")]
    fn connect_current_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "menu")]
    fn connect_menu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<TabSwitcher>> TabSwitcherExt for O {
    fn n_tabs(&self) -> i32 {
        unsafe {
            ffi::he_tab_switcher_get_n_tabs(self.as_ref().to_glib_none().0)
        }
    }

    fn tabs(&self) -> Vec<Tab> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::he_tab_switcher_get_tabs(self.as_ref().to_glib_none().0))
        }
    }

    fn tab_bar_behavior(&self) -> TabSwitcherTabBarBehavior {
        unsafe {
            from_glib(ffi::he_tab_switcher_get_tab_bar_behavior(self.as_ref().to_glib_none().0))
        }
    }

    fn set_tab_bar_behavior(&self, value: TabSwitcherTabBarBehavior) {
        unsafe {
            ffi::he_tab_switcher_set_tab_bar_behavior(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    fn tab_position(&self, tab: &impl IsA<Tab>) -> i32 {
        unsafe {
            ffi::he_tab_switcher_get_tab_position(self.as_ref().to_glib_none().0, tab.as_ref().to_glib_none().0)
        }
    }

    fn allows_duplicate_tabs(&self) -> bool {
        unsafe {
            from_glib(ffi::he_tab_switcher_get_allow_duplicate_tabs(self.as_ref().to_glib_none().0))
        }
    }

    fn set_allow_duplicate_tabs(&self, value: bool) {
        unsafe {
            ffi::he_tab_switcher_set_allow_duplicate_tabs(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    fn allows_drag(&self) -> bool {
        unsafe {
            from_glib(ffi::he_tab_switcher_get_allow_drag(self.as_ref().to_glib_none().0))
        }
    }

    fn set_allow_drag(&self, value: bool) {
        unsafe {
            ffi::he_tab_switcher_set_allow_drag(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    fn allows_pinning(&self) -> bool {
        unsafe {
            from_glib(ffi::he_tab_switcher_get_allow_pinning(self.as_ref().to_glib_none().0))
        }
    }

    fn set_allow_pinning(&self, value: bool) {
        unsafe {
            ffi::he_tab_switcher_set_allow_pinning(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    fn allows_closing(&self) -> bool {
        unsafe {
            from_glib(ffi::he_tab_switcher_get_allow_closing(self.as_ref().to_glib_none().0))
        }
    }

    fn set_allow_closing(&self, value: bool) {
        unsafe {
            ffi::he_tab_switcher_set_allow_closing(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    fn allows_new_window(&self) -> bool {
        unsafe {
            from_glib(ffi::he_tab_switcher_get_allow_new_window(self.as_ref().to_glib_none().0))
        }
    }

    fn set_allow_new_window(&self, value: bool) {
        unsafe {
            ffi::he_tab_switcher_set_allow_new_window(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    fn current(&self) -> Tab {
        unsafe {
            from_glib_none(ffi::he_tab_switcher_get_current(self.as_ref().to_glib_none().0))
        }
    }

    fn set_current(&self, value: &impl IsA<Tab>) {
        unsafe {
            ffi::he_tab_switcher_set_current(self.as_ref().to_glib_none().0, value.as_ref().to_glib_none().0);
        }
    }

    fn insert_tab(&self, tab: &impl IsA<Tab>, index: i32) -> u32 {
        unsafe {
            ffi::he_tab_switcher_insert_tab(self.as_ref().to_glib_none().0, tab.as_ref().to_glib_none().0, index)
        }
    }

    fn remove_tab(&self, tab: &impl IsA<Tab>) {
        unsafe {
            ffi::he_tab_switcher_remove_tab(self.as_ref().to_glib_none().0, tab.as_ref().to_glib_none().0);
        }
    }

    fn menu(&self) -> gio::Menu {
        unsafe {
            from_glib_none(ffi::he_tab_switcher_get_menu(self.as_ref().to_glib_none().0))
        }
    }

    fn actions(&self) -> gio::SimpleActionGroup {
        unsafe {
            from_glib_none(ffi::he_tab_switcher_get_actions(self.as_ref().to_glib_none().0))
        }
    }

    fn set_menu(&self, menu: Option<&gio::Menu>) {
        glib::ObjectExt::set_property(self.as_ref(),"menu", &menu)
    }

    fn connect_tab_added<F: Fn(&Self, &Tab) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn tab_added_trampoline<P: IsA<TabSwitcher>, F: Fn(&P, &Tab) + 'static>(this: *mut ffi::HeTabSwitcher, tab: *mut ffi::HeTab, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(tab))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"tab-added\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(tab_added_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_tab_removed<F: Fn(&Self, &Tab) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn tab_removed_trampoline<P: IsA<TabSwitcher>, F: Fn(&P, &Tab) + 'static>(this: *mut ffi::HeTabSwitcher, tab: *mut ffi::HeTab, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(tab))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"tab-removed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(tab_removed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_tab_switched<F: Fn(&Self, Option<&Tab>, &Tab) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn tab_switched_trampoline<P: IsA<TabSwitcher>, F: Fn(&P, Option<&Tab>, &Tab) + 'static>(this: *mut ffi::HeTabSwitcher, old_tab: *mut ffi::HeTab, new_tab: *mut ffi::HeTab, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref(), Option::<Tab>::from_glib_borrow(old_tab).as_ref().as_ref(), &from_glib_borrow(new_tab))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"tab-switched\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(tab_switched_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_tab_moved<F: Fn(&Self, &Tab) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn tab_moved_trampoline<P: IsA<TabSwitcher>, F: Fn(&P, &Tab) + 'static>(this: *mut ffi::HeTabSwitcher, tab: *mut ffi::HeTab, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(tab))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"tab-moved\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(tab_moved_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_tab_duplicated<F: Fn(&Self, &Tab) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn tab_duplicated_trampoline<P: IsA<TabSwitcher>, F: Fn(&P, &Tab) + 'static>(this: *mut ffi::HeTabSwitcher, duplicated_tab: *mut ffi::HeTab, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(duplicated_tab))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"tab-duplicated\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(tab_duplicated_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_new_tab_requested<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn new_tab_requested_trampoline<P: IsA<TabSwitcher>, F: Fn(&P) + 'static>(this: *mut ffi::HeTabSwitcher, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"new-tab-requested\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(new_tab_requested_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_close_tab_requested<F: Fn(&Self, &Tab) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn close_tab_requested_trampoline<P: IsA<TabSwitcher>, F: Fn(&P, &Tab) -> bool + 'static>(this: *mut ffi::HeTabSwitcher, tab: *mut ffi::HeTab, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(tab)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"close-tab-requested\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(close_tab_requested_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_n_tabs_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_n_tabs_trampoline<P: IsA<TabSwitcher>, F: Fn(&P) + 'static>(this: *mut ffi::HeTabSwitcher, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::n-tabs\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_n_tabs_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_tabs_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_tabs_trampoline<P: IsA<TabSwitcher>, F: Fn(&P) + 'static>(this: *mut ffi::HeTabSwitcher, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::tabs\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_tabs_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_tab_bar_behavior_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_tab_bar_behavior_trampoline<P: IsA<TabSwitcher>, F: Fn(&P) + 'static>(this: *mut ffi::HeTabSwitcher, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::tab-bar-behavior\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_tab_bar_behavior_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_allow_duplicate_tabs_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_allow_duplicate_tabs_trampoline<P: IsA<TabSwitcher>, F: Fn(&P) + 'static>(this: *mut ffi::HeTabSwitcher, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::allow-duplicate-tabs\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_allow_duplicate_tabs_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_allow_drag_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_allow_drag_trampoline<P: IsA<TabSwitcher>, F: Fn(&P) + 'static>(this: *mut ffi::HeTabSwitcher, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::allow-drag\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_allow_drag_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_allow_pinning_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_allow_pinning_trampoline<P: IsA<TabSwitcher>, F: Fn(&P) + 'static>(this: *mut ffi::HeTabSwitcher, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::allow-pinning\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_allow_pinning_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_allow_closing_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_allow_closing_trampoline<P: IsA<TabSwitcher>, F: Fn(&P) + 'static>(this: *mut ffi::HeTabSwitcher, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::allow-closing\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_allow_closing_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_allow_new_window_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_allow_new_window_trampoline<P: IsA<TabSwitcher>, F: Fn(&P) + 'static>(this: *mut ffi::HeTabSwitcher, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::allow-new-window\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_allow_new_window_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_current_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_current_trampoline<P: IsA<TabSwitcher>, F: Fn(&P) + 'static>(this: *mut ffi::HeTabSwitcher, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::current\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_current_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_menu_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_menu_trampoline<P: IsA<TabSwitcher>, F: Fn(&P) + 'static>(this: *mut ffi::HeTabSwitcher, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TabSwitcher::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::menu\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_menu_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for TabSwitcher {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("TabSwitcher")
    }
}
