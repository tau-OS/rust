// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files.git)
// DO NOT EDIT

use glib::{translate::*, value::FromValue, value::ToValue, StaticType, Type};
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "BisAlbumTransitionType")]
pub enum AlbumTransitionType {
    #[doc(alias = "BIS_ALBUM_TRANSITION_TYPE_OVER")]
    Over,
    #[doc(alias = "BIS_ALBUM_TRANSITION_TYPE_UNDER")]
    Under,
    #[doc(alias = "BIS_ALBUM_TRANSITION_TYPE_SLIDE")]
    Slide,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AlbumTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AlbumTransitionType::{}",
            match *self {
                Self::Over => "Over",
                Self::Under => "Under",
                Self::Slide => "Slide",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for AlbumTransitionType {
    type GlibType = ffi::BisAlbumTransitionType;

    #[inline]
    fn into_glib(self) -> ffi::BisAlbumTransitionType {
        match self {
            Self::Over => ffi::BIS_ALBUM_TRANSITION_TYPE_OVER,
            Self::Under => ffi::BIS_ALBUM_TRANSITION_TYPE_UNDER,
            Self::Slide => ffi::BIS_ALBUM_TRANSITION_TYPE_SLIDE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::BisAlbumTransitionType> for AlbumTransitionType {
    #[inline]
    unsafe fn from_glib(value: ffi::BisAlbumTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::BIS_ALBUM_TRANSITION_TYPE_OVER => Self::Over,
            ffi::BIS_ALBUM_TRANSITION_TYPE_UNDER => Self::Under,
            ffi::BIS_ALBUM_TRANSITION_TYPE_SLIDE => Self::Slide,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AlbumTransitionType {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::bis_album_transition_type_get_type()) }
    }
}

impl glib::value::ValueType for AlbumTransitionType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for AlbumTransitionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AlbumTransitionType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AlbumTransitionType> for glib::Value {
    #[inline]
    fn from(v: AlbumTransitionType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "BisAnimationState")]
pub enum AnimationState {
    #[doc(alias = "BIS_ANIMATION_IDLE")]
    Idle,
    #[doc(alias = "BIS_ANIMATION_PAUSED")]
    Paused,
    #[doc(alias = "BIS_ANIMATION_PLAYING")]
    Playing,
    #[doc(alias = "BIS_ANIMATION_FINISHED")]
    Finished,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AnimationState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AnimationState::{}",
            match *self {
                Self::Idle => "Idle",
                Self::Paused => "Paused",
                Self::Playing => "Playing",
                Self::Finished => "Finished",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for AnimationState {
    type GlibType = ffi::BisAnimationState;

    #[inline]
    fn into_glib(self) -> ffi::BisAnimationState {
        match self {
            Self::Idle => ffi::BIS_ANIMATION_IDLE,
            Self::Paused => ffi::BIS_ANIMATION_PAUSED,
            Self::Playing => ffi::BIS_ANIMATION_PLAYING,
            Self::Finished => ffi::BIS_ANIMATION_FINISHED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::BisAnimationState> for AnimationState {
    #[inline]
    unsafe fn from_glib(value: ffi::BisAnimationState) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::BIS_ANIMATION_IDLE => Self::Idle,
            ffi::BIS_ANIMATION_PAUSED => Self::Paused,
            ffi::BIS_ANIMATION_PLAYING => Self::Playing,
            ffi::BIS_ANIMATION_FINISHED => Self::Finished,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AnimationState {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::bis_animation_state_get_type()) }
    }
}

impl glib::value::ValueType for AnimationState {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for AnimationState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AnimationState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AnimationState> for glib::Value {
    #[inline]
    fn from(v: AnimationState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "BisEasing")]
pub enum Easing {
    #[doc(alias = "BIS_LINEAR")]
    Linear,
    #[doc(alias = "BIS_EASE_IN_QUAD")]
    EaseInQuad,
    #[doc(alias = "BIS_EASE_OUT_QUAD")]
    EaseOutQuad,
    #[doc(alias = "BIS_EASE_IN_OUT_QUAD")]
    EaseInOutQuad,
    #[doc(alias = "BIS_EASE_IN_CUBIC")]
    EaseInCubic,
    #[doc(alias = "BIS_EASE_OUT_CUBIC")]
    EaseOutCubic,
    #[doc(alias = "BIS_EASE_IN_OUT_CUBIC")]
    EaseInOutCubic,
    #[doc(alias = "BIS_EASE_IN_QUART")]
    EaseInQuart,
    #[doc(alias = "BIS_EASE_OUT_QUART")]
    EaseOutQuart,
    #[doc(alias = "BIS_EASE_IN_OUT_QUART")]
    EaseInOutQuart,
    #[doc(alias = "BIS_EASE_IN_QUINT")]
    EaseInQuint,
    #[doc(alias = "BIS_EASE_OUT_QUINT")]
    EaseOutQuint,
    #[doc(alias = "BIS_EASE_IN_OUT_QUINT")]
    EaseInOutQuint,
    #[doc(alias = "BIS_EASE_IN_SINE")]
    EaseInSine,
    #[doc(alias = "BIS_EASE_OUT_SINE")]
    EaseOutSine,
    #[doc(alias = "BIS_EASE_IN_OUT_SINE")]
    EaseInOutSine,
    #[doc(alias = "BIS_EASE_IN_EXPO")]
    EaseInExpo,
    #[doc(alias = "BIS_EASE_OUT_EXPO")]
    EaseOutExpo,
    #[doc(alias = "BIS_EASE_IN_OUT_EXPO")]
    EaseInOutExpo,
    #[doc(alias = "BIS_EASE_IN_CIRC")]
    EaseInCirc,
    #[doc(alias = "BIS_EASE_OUT_CIRC")]
    EaseOutCirc,
    #[doc(alias = "BIS_EASE_IN_OUT_CIRC")]
    EaseInOutCirc,
    #[doc(alias = "BIS_EASE_IN_ELASTIC")]
    EaseInElastic,
    #[doc(alias = "BIS_EASE_OUT_ELASTIC")]
    EaseOutElastic,
    #[doc(alias = "BIS_EASE_IN_OUT_ELASTIC")]
    EaseInOutElastic,
    #[doc(alias = "BIS_EASE_IN_BACK")]
    EaseInBack,
    #[doc(alias = "BIS_EASE_OUT_BACK")]
    EaseOutBack,
    #[doc(alias = "BIS_EASE_IN_OUT_BACK")]
    EaseInOutBack,
    #[doc(alias = "BIS_EASE_IN_BOUNCE")]
    EaseInBounce,
    #[doc(alias = "BIS_EASE_OUT_BOUNCE")]
    EaseOutBounce,
    #[doc(alias = "BIS_EASE_IN_OUT_BOUNCE")]
    EaseInOutBounce,
    #[doc(hidden)]
    __Unknown(i32),
}

impl Easing {
    #[doc(alias = "bis_easing_ease")]
    pub fn ease(self, value: f64) -> f64 {
        assert_initialized_main_thread!();
        unsafe { ffi::bis_easing_ease(self.into_glib(), value) }
    }
}

impl fmt::Display for Easing {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Easing::{}",
            match *self {
                Self::Linear => "Linear",
                Self::EaseInQuad => "EaseInQuad",
                Self::EaseOutQuad => "EaseOutQuad",
                Self::EaseInOutQuad => "EaseInOutQuad",
                Self::EaseInCubic => "EaseInCubic",
                Self::EaseOutCubic => "EaseOutCubic",
                Self::EaseInOutCubic => "EaseInOutCubic",
                Self::EaseInQuart => "EaseInQuart",
                Self::EaseOutQuart => "EaseOutQuart",
                Self::EaseInOutQuart => "EaseInOutQuart",
                Self::EaseInQuint => "EaseInQuint",
                Self::EaseOutQuint => "EaseOutQuint",
                Self::EaseInOutQuint => "EaseInOutQuint",
                Self::EaseInSine => "EaseInSine",
                Self::EaseOutSine => "EaseOutSine",
                Self::EaseInOutSine => "EaseInOutSine",
                Self::EaseInExpo => "EaseInExpo",
                Self::EaseOutExpo => "EaseOutExpo",
                Self::EaseInOutExpo => "EaseInOutExpo",
                Self::EaseInCirc => "EaseInCirc",
                Self::EaseOutCirc => "EaseOutCirc",
                Self::EaseInOutCirc => "EaseInOutCirc",
                Self::EaseInElastic => "EaseInElastic",
                Self::EaseOutElastic => "EaseOutElastic",
                Self::EaseInOutElastic => "EaseInOutElastic",
                Self::EaseInBack => "EaseInBack",
                Self::EaseOutBack => "EaseOutBack",
                Self::EaseInOutBack => "EaseInOutBack",
                Self::EaseInBounce => "EaseInBounce",
                Self::EaseOutBounce => "EaseOutBounce",
                Self::EaseInOutBounce => "EaseInOutBounce",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for Easing {
    type GlibType = ffi::BisEasing;

    fn into_glib(self) -> ffi::BisEasing {
        match self {
            Self::Linear => ffi::BIS_LINEAR,
            Self::EaseInQuad => ffi::BIS_EASE_IN_QUAD,
            Self::EaseOutQuad => ffi::BIS_EASE_OUT_QUAD,
            Self::EaseInOutQuad => ffi::BIS_EASE_IN_OUT_QUAD,
            Self::EaseInCubic => ffi::BIS_EASE_IN_CUBIC,
            Self::EaseOutCubic => ffi::BIS_EASE_OUT_CUBIC,
            Self::EaseInOutCubic => ffi::BIS_EASE_IN_OUT_CUBIC,
            Self::EaseInQuart => ffi::BIS_EASE_IN_QUART,
            Self::EaseOutQuart => ffi::BIS_EASE_OUT_QUART,
            Self::EaseInOutQuart => ffi::BIS_EASE_IN_OUT_QUART,
            Self::EaseInQuint => ffi::BIS_EASE_IN_QUINT,
            Self::EaseOutQuint => ffi::BIS_EASE_OUT_QUINT,
            Self::EaseInOutQuint => ffi::BIS_EASE_IN_OUT_QUINT,
            Self::EaseInSine => ffi::BIS_EASE_IN_SINE,
            Self::EaseOutSine => ffi::BIS_EASE_OUT_SINE,
            Self::EaseInOutSine => ffi::BIS_EASE_IN_OUT_SINE,
            Self::EaseInExpo => ffi::BIS_EASE_IN_EXPO,
            Self::EaseOutExpo => ffi::BIS_EASE_OUT_EXPO,
            Self::EaseInOutExpo => ffi::BIS_EASE_IN_OUT_EXPO,
            Self::EaseInCirc => ffi::BIS_EASE_IN_CIRC,
            Self::EaseOutCirc => ffi::BIS_EASE_OUT_CIRC,
            Self::EaseInOutCirc => ffi::BIS_EASE_IN_OUT_CIRC,
            Self::EaseInElastic => ffi::BIS_EASE_IN_ELASTIC,
            Self::EaseOutElastic => ffi::BIS_EASE_OUT_ELASTIC,
            Self::EaseInOutElastic => ffi::BIS_EASE_IN_OUT_ELASTIC,
            Self::EaseInBack => ffi::BIS_EASE_IN_BACK,
            Self::EaseOutBack => ffi::BIS_EASE_OUT_BACK,
            Self::EaseInOutBack => ffi::BIS_EASE_IN_OUT_BACK,
            Self::EaseInBounce => ffi::BIS_EASE_IN_BOUNCE,
            Self::EaseOutBounce => ffi::BIS_EASE_OUT_BOUNCE,
            Self::EaseInOutBounce => ffi::BIS_EASE_IN_OUT_BOUNCE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::BisEasing> for Easing {
    unsafe fn from_glib(value: ffi::BisEasing) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::BIS_LINEAR => Self::Linear,
            ffi::BIS_EASE_IN_QUAD => Self::EaseInQuad,
            ffi::BIS_EASE_OUT_QUAD => Self::EaseOutQuad,
            ffi::BIS_EASE_IN_OUT_QUAD => Self::EaseInOutQuad,
            ffi::BIS_EASE_IN_CUBIC => Self::EaseInCubic,
            ffi::BIS_EASE_OUT_CUBIC => Self::EaseOutCubic,
            ffi::BIS_EASE_IN_OUT_CUBIC => Self::EaseInOutCubic,
            ffi::BIS_EASE_IN_QUART => Self::EaseInQuart,
            ffi::BIS_EASE_OUT_QUART => Self::EaseOutQuart,
            ffi::BIS_EASE_IN_OUT_QUART => Self::EaseInOutQuart,
            ffi::BIS_EASE_IN_QUINT => Self::EaseInQuint,
            ffi::BIS_EASE_OUT_QUINT => Self::EaseOutQuint,
            ffi::BIS_EASE_IN_OUT_QUINT => Self::EaseInOutQuint,
            ffi::BIS_EASE_IN_SINE => Self::EaseInSine,
            ffi::BIS_EASE_OUT_SINE => Self::EaseOutSine,
            ffi::BIS_EASE_IN_OUT_SINE => Self::EaseInOutSine,
            ffi::BIS_EASE_IN_EXPO => Self::EaseInExpo,
            ffi::BIS_EASE_OUT_EXPO => Self::EaseOutExpo,
            ffi::BIS_EASE_IN_OUT_EXPO => Self::EaseInOutExpo,
            ffi::BIS_EASE_IN_CIRC => Self::EaseInCirc,
            ffi::BIS_EASE_OUT_CIRC => Self::EaseOutCirc,
            ffi::BIS_EASE_IN_OUT_CIRC => Self::EaseInOutCirc,
            ffi::BIS_EASE_IN_ELASTIC => Self::EaseInElastic,
            ffi::BIS_EASE_OUT_ELASTIC => Self::EaseOutElastic,
            ffi::BIS_EASE_IN_OUT_ELASTIC => Self::EaseInOutElastic,
            ffi::BIS_EASE_IN_BACK => Self::EaseInBack,
            ffi::BIS_EASE_OUT_BACK => Self::EaseOutBack,
            ffi::BIS_EASE_IN_OUT_BACK => Self::EaseInOutBack,
            ffi::BIS_EASE_IN_BOUNCE => Self::EaseInBounce,
            ffi::BIS_EASE_OUT_BOUNCE => Self::EaseOutBounce,
            ffi::BIS_EASE_IN_OUT_BOUNCE => Self::EaseInOutBounce,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Easing {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::bis_easing_get_type()) }
    }
}

impl glib::value::ValueType for Easing {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for Easing {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Easing {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Easing> for glib::Value {
    #[inline]
    fn from(v: Easing) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "BisFoldThresholdPolicy")]
pub enum FoldThresholdPolicy {
    #[doc(alias = "BIS_FOLD_THRESHOLD_POLICY_MINIMUM")]
    Minimum,
    #[doc(alias = "BIS_FOLD_THRESHOLD_POLICY_NATURAL")]
    Natural,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FoldThresholdPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FoldThresholdPolicy::{}",
            match *self {
                Self::Minimum => "Minimum",
                Self::Natural => "Natural",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for FoldThresholdPolicy {
    type GlibType = ffi::BisFoldThresholdPolicy;

    #[inline]
    fn into_glib(self) -> ffi::BisFoldThresholdPolicy {
        match self {
            Self::Minimum => ffi::BIS_FOLD_THRESHOLD_POLICY_MINIMUM,
            Self::Natural => ffi::BIS_FOLD_THRESHOLD_POLICY_NATURAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::BisFoldThresholdPolicy> for FoldThresholdPolicy {
    #[inline]
    unsafe fn from_glib(value: ffi::BisFoldThresholdPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::BIS_FOLD_THRESHOLD_POLICY_MINIMUM => Self::Minimum,
            ffi::BIS_FOLD_THRESHOLD_POLICY_NATURAL => Self::Natural,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for FoldThresholdPolicy {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::bis_fold_threshold_policy_get_type()) }
    }
}

impl glib::value::ValueType for FoldThresholdPolicy {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FoldThresholdPolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FoldThresholdPolicy {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<FoldThresholdPolicy> for glib::Value {
    #[inline]
    fn from(v: FoldThresholdPolicy) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "BisHuggerTransitionType")]
pub enum HuggerTransitionType {
    #[doc(alias = "BIS_HUGGER_TRANSITION_TYPE_NONE")]
    None,
    #[doc(alias = "BIS_HUGGER_TRANSITION_TYPE_CROSSFADE")]
    Crossfade,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for HuggerTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "HuggerTransitionType::{}",
            match *self {
                Self::None => "None",
                Self::Crossfade => "Crossfade",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for HuggerTransitionType {
    type GlibType = ffi::BisHuggerTransitionType;

    #[inline]
    fn into_glib(self) -> ffi::BisHuggerTransitionType {
        match self {
            Self::None => ffi::BIS_HUGGER_TRANSITION_TYPE_NONE,
            Self::Crossfade => ffi::BIS_HUGGER_TRANSITION_TYPE_CROSSFADE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::BisHuggerTransitionType> for HuggerTransitionType {
    #[inline]
    unsafe fn from_glib(value: ffi::BisHuggerTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::BIS_HUGGER_TRANSITION_TYPE_NONE => Self::None,
            ffi::BIS_HUGGER_TRANSITION_TYPE_CROSSFADE => Self::Crossfade,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for HuggerTransitionType {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::bis_hugger_transition_type_get_type()) }
    }
}

impl glib::value::ValueType for HuggerTransitionType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for HuggerTransitionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for HuggerTransitionType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<HuggerTransitionType> for glib::Value {
    #[inline]
    fn from(v: HuggerTransitionType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "BisLapelFoldPolicy")]
pub enum LapelFoldPolicy {
    #[doc(alias = "BIS_LAPEL_FOLD_POLICY_NEVER")]
    Never,
    #[doc(alias = "BIS_LAPEL_FOLD_POLICY_ALWAYS")]
    Always,
    #[doc(alias = "BIS_LAPEL_FOLD_POLICY_AUTO")]
    Auto,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for LapelFoldPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "LapelFoldPolicy::{}",
            match *self {
                Self::Never => "Never",
                Self::Always => "Always",
                Self::Auto => "Auto",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for LapelFoldPolicy {
    type GlibType = ffi::BisLapelFoldPolicy;

    #[inline]
    fn into_glib(self) -> ffi::BisLapelFoldPolicy {
        match self {
            Self::Never => ffi::BIS_LAPEL_FOLD_POLICY_NEVER,
            Self::Always => ffi::BIS_LAPEL_FOLD_POLICY_ALWAYS,
            Self::Auto => ffi::BIS_LAPEL_FOLD_POLICY_AUTO,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::BisLapelFoldPolicy> for LapelFoldPolicy {
    #[inline]
    unsafe fn from_glib(value: ffi::BisLapelFoldPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::BIS_LAPEL_FOLD_POLICY_NEVER => Self::Never,
            ffi::BIS_LAPEL_FOLD_POLICY_ALWAYS => Self::Always,
            ffi::BIS_LAPEL_FOLD_POLICY_AUTO => Self::Auto,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for LapelFoldPolicy {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::bis_lapel_fold_policy_get_type()) }
    }
}

impl glib::value::ValueType for LapelFoldPolicy {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for LapelFoldPolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for LapelFoldPolicy {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<LapelFoldPolicy> for glib::Value {
    #[inline]
    fn from(v: LapelFoldPolicy) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "BisLapelTransitionType")]
pub enum LapelTransitionType {
    #[doc(alias = "BIS_LAPEL_TRANSITION_TYPE_OVER")]
    Over,
    #[doc(alias = "BIS_LAPEL_TRANSITION_TYPE_UNDER")]
    Under,
    #[doc(alias = "BIS_LAPEL_TRANSITION_TYPE_SLIDE")]
    Slide,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for LapelTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "LapelTransitionType::{}",
            match *self {
                Self::Over => "Over",
                Self::Under => "Under",
                Self::Slide => "Slide",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for LapelTransitionType {
    type GlibType = ffi::BisLapelTransitionType;

    #[inline]
    fn into_glib(self) -> ffi::BisLapelTransitionType {
        match self {
            Self::Over => ffi::BIS_LAPEL_TRANSITION_TYPE_OVER,
            Self::Under => ffi::BIS_LAPEL_TRANSITION_TYPE_UNDER,
            Self::Slide => ffi::BIS_LAPEL_TRANSITION_TYPE_SLIDE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::BisLapelTransitionType> for LapelTransitionType {
    #[inline]
    unsafe fn from_glib(value: ffi::BisLapelTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::BIS_LAPEL_TRANSITION_TYPE_OVER => Self::Over,
            ffi::BIS_LAPEL_TRANSITION_TYPE_UNDER => Self::Under,
            ffi::BIS_LAPEL_TRANSITION_TYPE_SLIDE => Self::Slide,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for LapelTransitionType {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::bis_lapel_transition_type_get_type()) }
    }
}

impl glib::value::ValueType for LapelTransitionType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for LapelTransitionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for LapelTransitionType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<LapelTransitionType> for glib::Value {
    #[inline]
    fn from(v: LapelTransitionType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "BisNavigationDirection")]
pub enum NavigationDirection {
    #[doc(alias = "BIS_NAVIGATION_DIRECTION_BACK")]
    Back,
    #[doc(alias = "BIS_NAVIGATION_DIRECTION_FORWARD")]
    Forward,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NavigationDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NavigationDirection::{}",
            match *self {
                Self::Back => "Back",
                Self::Forward => "Forward",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for NavigationDirection {
    type GlibType = ffi::BisNavigationDirection;

    #[inline]
    fn into_glib(self) -> ffi::BisNavigationDirection {
        match self {
            Self::Back => ffi::BIS_NAVIGATION_DIRECTION_BACK,
            Self::Forward => ffi::BIS_NAVIGATION_DIRECTION_FORWARD,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::BisNavigationDirection> for NavigationDirection {
    #[inline]
    unsafe fn from_glib(value: ffi::BisNavigationDirection) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::BIS_NAVIGATION_DIRECTION_BACK => Self::Back,
            ffi::BIS_NAVIGATION_DIRECTION_FORWARD => Self::Forward,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for NavigationDirection {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::bis_navigation_direction_get_type()) }
    }
}

impl glib::value::ValueType for NavigationDirection {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for NavigationDirection {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for NavigationDirection {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<NavigationDirection> for glib::Value {
    #[inline]
    fn from(v: NavigationDirection) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
